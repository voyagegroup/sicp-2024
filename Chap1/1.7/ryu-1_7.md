## 問1.7


### 問題に関する関数
```
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square a) (* a a))
```

### 動作を思い出すメモ

```
(good-enough? 1.0 9)
(< (abs (- (square 1.0) 9)) 0.001)
(< (abs (- (* 1.0 1.0) 9)) 0.001)
(< (abs (- 1.0 9)) 0.001)
(< (abs 8) 0.001)
(< 8 0.001)
→ false
```

```
(good-enough? 2.5 9)
(< (abs (- (square 2.5) 9)) 0.001)
(< (abs (- 6.25 9)) 0.001)
(< 2.75 0.001)
→ false
```

```
(good-enough? 3.0 9)
(< (abs (- (square 3.0) 9)) 0.001)
(< (abs (- 9 9)) 0.001)
(< 0 0.001)
→ true
```

### 小さい値

```
(sqrt 0.00000000000000000000000000000000000000009)
; -> 0.03125
```

元が小さいと、差分のしきい値の0.001をすぐに下回ってしまうため、十分な制度が出る前にgood-enough?がtrueになってしまう。

### 大きい値

```
(sqrt 900000000000000000000000000000000000000000000000000000)
; 処理が終わらない
```

元が大きいと、good-enough?がtrueになるまで相当数処理をし続けてしまう。

### 差分を使った推定

> good-enough?を実装するもう一つの戦略は, ある繰返しから次へのguessの変化に注目し, 変化が予測値に比べ非常に小さくなった時に止めるのである. こういう終了テストを使う平方根手続きを設計せよ.

もともとのgood-enough?は、guessを二乗した値とyとを比較して、十分かを評価している。

次へのguessの変化に注目し, 変化が予測値に比べ非常に小さくなった時に止める
ということは、前後のguessを使うってことかな？
`(good-enough-v2? guess prev-guess)` みたいな感じで前後比較できるようにしてみる。

```
(define (good-enough-v2? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (sqrt-iter-v2 guess prev-guess x)
  (if (good-enough-v2? guess prev-guess)
      guess
      (sqrt-iter-v2 (improve guess x) guess x)))


(define (sqrt-v2 x)
  (sqrt-iter-v2 1.0 0.0 x))

(sqrt-v2 0.002)
; → 0.04472230608683239
(sqrt-v2 900000000000000000000000000000000000000000000000000000)
; -> 9.486832996751417e+26
(sqrt-v2 0.00000000000000000000000000000000000000009)
; -> 9.486832984052367e-21
```

計算できるようになった。

### 処理を追っていく

```
(sqrt-v2 9)
; 本体を取り出す
(sqrt-iter-v2 1.0 0.0 9)
; 本体を取り出す
(if (good-enough-v2? 1.0 0.0)
    1.0
    (sqrt-iter-v2 (improve 1.0 9) 1.0 9))
; ifのpredicateを評価
(good-enough-v2? 1.0 0.0)
; 本体を取り出す
(< (abs (/ (- 1.0 0.0) 1.0)) 0.001)
; 部分式を評価
(< (abs (/ -1.0 1.0)) 0.001)
(< (abs -1.0) 0.001)
(< 1.0 0.001)
; -> #f
; predicate -> #f なので、alternativeを評価する
(sqrt-iter-v2 (improve 1.0 9) 1.0 9)
; (improve 1.0 9) -> 5.0だったので省略
(sqrt-iter-v2 5.0 1.0 9)
; 本体を取り出す
(if (good-enough-v2? 5.0 1.0)
    5.0
    (sqrt-iter-v2 (improve 5.0 9) 5.0 9))
; predicateを評価
(good-enough-v2? 5.0 1.0)
; 本体を取り出す
(< (abs (/ (- 5.0 1.0) 5.0)) 0.001)
; 部分式を評価
(< (abs -0.8) 0.001)
(< 0.8 0.001)
; -> #f
```


```
; #tがでるところ
(good-enough-v2? 3.000 3.002)
(< (abs (/ (- 3.000 3.0002) 3.000)) 0.001)
; 部分式を評価（- 3.000 3.0002）は、実際は誤差が出ていた
(< (abs (/ -0.0002 3.000)) 0.001)
(< (abs (-0.00006667) 0.001))
(< 0.00006667 0.001)
; -> #t
```

