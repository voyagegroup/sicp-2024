## 置き換えモデルの順を追ってみる

```
#lang sicp

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(A 1 10)
; 1024

(A 2 4)
; 65536

(A 3 3)
; 65536

; 1つ目の例の (A 1 10) の置き換えモデルのステップを追ってみる
(A 1 10)
; x=1, y=10
(cond ((= 10 0) 0)
      ((= 1 0) (* 2 10))
      ((= 10 1) 2)
      (else (A (- 1 1)
               (A 1 (- 10 1)))))
; else
(A (- 1 1) (A 1 (- 10 1)))
(A 0 (A 1 9))
; (A 1 9) を評価していく
(A 1 9)
; x=1, y=9
(cond ((= 9 0) 0)
      ((= 1 0) (* 2 9))
      ((= 9 1) 2)
      (else (A (- 1 1) (A 1 (- 9 1)))))
; else
(A (- 1 1) (A 1 (- 9 1)))
(A 0 (A 1 8))
; (A 1 9) 
; -> (A 0 (A 1 8))
(A 0 (A 0 (A 1 8)))
; (A 1 8) を評価していく
(A 1 8)
; else
(A (- 1 1) (A 1 (- 8 1)))
(A 0 (A 1 7))
; (A 1 8)
; -> (A 0 (A 1 7))
(A 0 (A 0 (A 0 (A 1 7))))
; y が 1ずつへっていく
; y = 1になるまでネストしていく
; y = 1 まで略
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
; (A 1 1) を評価していく
(A 1 1)
; -> 2
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
; (A 0 2) を評価していく
(A 0 2)
; (= x 0) が #t になる
(* 2 2)
; -> 4
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
; (A 0 4) を評価していく
(A 0 4)
; (= x 0) が #t になる
(* 2 4)
; -> 8
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
;....
; -> 1024

```

```
; 2つ目の例の (A 2 4) の置き換えモデルのステップを追ってみる
(A 2 4)
; else に行く
(A (- 2 1) (A 2 (- 4 1)))
(A 1 (A 2 3))
; (A 2 3) を評価していく
; else に行く
(A (- 2 1) (A 2 (- 3 1)))
(A 1 (A 2 2))
; (A 2 3)
; -> (A 1 (A 2 2))
(A 1 (A 1 (A 2 2)))
; (A 2 2) を評価していく
; else に行く
(A 1 (A 2 1))
; (A 2 2)
; -> (A 1 (A 2 1))
(A 1 (A 1 (A 1 (A 2 1))))
; (A 2 1) を評価していく
(A 2 1)
; (= y 1) が #t になる
; (A 2 1)
; -> 2
(A 1 (A 1 (A 1 2)))
; (A 1 2) を評価していく
(A 1 2)
; else に行く
(A (- 1 1) (A 1 (- 2 1)))
(A 0 (A 1 1))
; (A 1 2)
; -> (A 0 (A 1 1))
(A 1 (A 1 (A 0 (A 1 1))))
; (A 1 1) を評価していく
(A 1 1)
; (= y 1) が #t になる
(A 1 (A 1 (A 0 2)))
; (A 0 2) を評価していく
(A 0 2)
; (= x 0) が #t になる
(* 2 2)
4
; (A 0 2)
; -> 4
(A 1 (A 1 4))
; (A 1 4) を評価していく
; else に行く
(A (- 1 1) (A 1 (- 4 1)))
(A 0 (A 1 3))
; (A 1 4)
; -> (A 0 (A 1 3))
(A 1 (A 0 (A 1 3)))
; (A 1 3) を評価していく
; else に行く
(A 0 (A 1 2))
; (A 1 3)
; -> (A 0 (A 1 2))
(A 1 (A 0 (A 0 (A 1 2))))
; (A 1 2) は計算済みなので略
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
; (A 1 1) は (= y 1) #t になるので 2 になる
(A 1 (A 0 (A 0 (A 0 2))))
; (A 0 2) は (= x 0) が #t になるので、 (* 2 2) で 4 になる
(A 1 (A 0 (A 0 4)))
; (A 0 4) は (= x 0) が #t になるので、 (* 4 2) で 8 になる
(A 1 (A 0 8))
; (A 0 8) は (= x 0) が #t になるので、 (* 8 2) で 16 になる
(A 1 16)
; (A 1 n) は 2^n になるので 2^16 で 65536 になる
```

## 回答

### `(define (f n) (A 0 n))`

```
(define (f n) (A 0 n))
(f 4)
; -> 8
(f 9)
; -> 18
```
(= x 0) が常に #t になるので、(* 2 y) が実行される
A. 2\*nを計算する

### `(define (g n) (A 1 n))`

```
(define (g n) (A 1 n))
(g 0)
; -> 0
(g 4)
; -> 16
(g 9)
; -> 512
```

A. n != 0 のとき、2^n を計算する

### `(define (h n) (A 2 n))`

```
(define (h n) (A 2 n))
(h 0)
(h 1)
; -> 2
(h 2)
; -> 4
(h 3)
; 2^2^2
; 2^4
; -> 16
(h 4)
; 2^2^2^2
; 2^2^4
; 2^16
; -> 65536
```

A. n != 0 のとき、nの数だけ二乗されていく


